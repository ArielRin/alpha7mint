
  const [stakeAmount, setStakeAmount] = useState('');
  const toast = useToast();

  // Approve Function
  const [isApprovalPending, setIsApprovalPending] = useState(false);
  const [isApproved, setIsApproved] = useState(false);

  const handleApprove = async () => {
    if (!stakeAmount) {
      toast({
        title: 'Error',
        description: 'Please enter an amount to approve.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return;
    }

    setIsApprovalPending(true); // Set approval pending status to true

    try {
        const provider = new ethers.providers.Web3Provider(window.ethereum as ExternalProvider);
      const signer = provider.getSigner();
      const tokenContract = new ethers.Contract(TOKEN_CONTRACT_ADDRESS, tokenAbi, signer);

      const amountToApprove = ethers.utils.parseUnits(stakeAmount, 9);
      const tx = await tokenContract.approve(STAKING_CONTRACT_ADDRESS, amountToApprove);
      await tx.wait();

      setIsApproved(true); // Set approved status to true
      setIsApprovalPending(false); // Reset approval pending status

      toast({
        title: 'Approval Successful',
        description: `You've approved ${stakeAmount} tokens for staking.`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
    } catch (error) {
      setIsApprovalPending(false); // Reset approval pending status on error
      console.error('Approval failed:', error);
      toast({
        title: 'Approval Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  };

  // Deposit Function
  const handleDeposit = async () => {
    if (!stakeAmount) {
      toast({
        title: 'Error',
        description: 'Please enter an amount to deposit.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return;
    }

    try {
        const provider = new ethers.providers.Web3Provider(window.ethereum as ExternalProvider);
      const signer = provider.getSigner();
      const stakingContract = new ethers.Contract(STAKING_CONTRACT_ADDRESS, stake14Abi, signer);

      const amountToDeposit = ethers.utils.parseUnits(stakeAmount, 9); // Adjusting for token's 9 decimal places
      const tx = await stakingContract.deposit(amountToDeposit);
      await tx.wait();

      toast({
        title: 'Deposit Successful',
        description: `You've successfully staked ${stakeAmount} tokens.`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
      setStakeAmount(''); // Optionally reset stake amount
    } catch (error) {
      console.error('Deposit failed:', error);
      toast({
        title: 'Deposit Failed',
        description: error.message,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  };

  // #################################################################################################
  // withdraw and emergency withdraw
  const { writeAsync: withdrawTokens } = useContractWrite({
    addressOrName: STAKING_CONTRACT_ADDRESS,
    contractInterface: stake14Abi,
    functionName: 'withdraw',
  });

  const { writeAsync: emergencyWithdrawTokens } = useContractWrite({
    addressOrName: STAKING_CONTRACT_ADDRESS,
    contractInterface: stake14Abi,
    functionName: 'emergencyWithdraw',
  });

  // withdraw 14
  const [isWithdrawing, setIsWithdrawing] = useState(false);

  const handleWithdraw = async () => {
    try {
      setIsWithdrawing(true);
      const tx = await withdrawTokens();
      await tx.wait();
      toast.success('Withdrawal successful!');
    } catch (error) {
      console.error('Withdrawal failed:', error);
      toast.error('Withdrawal unsuccessful. Please try again.');
    } finally {
      setIsWithdrawing(false);
    }
  };

  // emergencyWithdraw
  const [isEmergencyWithdrawing, setIsEmergencyWithdrawing] = useState(false);

  const handleEmergencyWithdraw = async () => {
    try {
      setIsEmergencyWithdrawing(true);
      const tx = await emergencyWithdrawTokens();
      await tx.wait();
      toast.success('Emergency withdrawal successful!');
    } catch (error) {
      console.error('Emergency withdrawal failed:', error);
      toast.error('Emergency withdrawal unsuccessful. Please try again.');
    } finally {
      setIsEmergencyWithdrawing(false);
    }
  };

  // #################################################################################################
  const headerTextStyle = {
    fontSize: '28px', // Increased font size
    fontWeight: 'bold', // Make the text bolder
    color: '#f8f8ff', // Off-white color
  };


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// fetchUserStakedBalance
  const [userStakedBalance, setUserStakedBalance] = useState(0);

  const fetchUserStakedBalance = async () => {
  try {
      const provider = new ethers.providers.Web3Provider(window.ethereum as ExternalProvider);
    const stakingContract = new ethers.Contract(STAKING_CONTRACT_ADDRESS, stake14Abi, provider);
    const signer = provider.getSigner();
    const userAddress = await signer.getAddress();
    const userInfo = await stakingContract.userInfo(userAddress);
    const userStakedAmount = ethers.utils.formatUnits(userInfo.amount, 9); // Adjust for your token's decimals
    setUserStakedBalance(parseFloat(userStakedAmount));
  } catch (error) {
    console.error('Failed to fetch user staked balance:', error);
  }
};

// _____________-----------______------__--_-_-_-_--_-_-_------__---_--_-_---___----_--_--_-_--_--
// _____________-----------______------__--_-_-_-_--_-_-_------__---_--_-_---___----_--_--_-_--_--
// _____________-----------______------__--_-_-_-_--_-_-_------__---_--_-_---___----_--_--_-_--_--
// _____________-----------______------__--_-_-_-_--_-_-_------__---_--_-_---___----_--_--_-_--_--
// _____________-----------______------__--_-_-_-_--_-_-_------__---_--_-_---___----_--_--_-_--_--
const [userAddress, setUserAddress] = useState('');
 const [userTokenBalance, setUserTokenBalance] = useState('0');
 const [unlockDate, setUnlockDate] = useState('');

 // Fetch user's Ethereum address
 useEffect(() => {
   const fetchUserAddress = async () => {
     if (window.ethereum) {
         const provider = new ethers.providers.Web3Provider(window.ethereum as ExternalProvider);
       try {
         await provider.send('eth_requestAccounts', []);
         const signer = provider.getSigner();
         const address = await signer.getAddress();
         setUserAddress(address);
         fetchUserTokenBalance(address); // Fetch token balance as soon as we have the user's address
       } catch (error) {
         console.error('Error fetching user address:', error);
       }
     }
   };

   fetchUserAddress();
 }, []);

 // Fetch user's token balance
 const fetchUserTokenBalance = async (address) => {
   if (!address) return;
     const provider = new ethers.providers.Web3Provider(window.ethereum as ExternalProvider);
   const tokenContract = new ethers.Contract(TOKEN_ADDRESS, tokenAbi, provider);
   try {
     const balance = await tokenContract.balanceOf(address);
     const formattedBalance = ethers.utils.formatUnits(balance, 9); // Token has 9 decimals
     setUserTokenBalance(formattedBalance);
   } catch (error) {
     console.error('Error fetching token balance:', error);
   }
 };

 // Fetch unlock date for staking
 useEffect(() => {
   const fetchUnlockDate = async () => {
     if (!userAddress) return;
       const provider = new ethers.providers.Web3Provider(window.ethereum as ExternalProvider);
     const stakingContract = new ethers.Contract(STAKING_CONTRACT_ADDRESS, stake14Abi, provider);
     try {
       const unlockTime = await stakingContract.holderUnlockTime(userAddress);
       const date = new Date(unlockTime.toNumber() * 1000).toLocaleString();
       setUnlockDate(date);
     } catch (error) {
       console.error('Error fetching unlock date:', error);
       setUnlockDate('Error fetching date');
     }
   };

   fetchUnlockDate();
 }, [userAddress]); // Depend on userAddress to refetch when it changes


  // #################################################################################################
    // #################################################################################################
      // #################################################################################################


  const [isClaiming, setIsClaiming] = useState(false);

   // Function to claim rewards
   const claimRewards = async () => {
     if (window.ethereum) {
       try {
         setIsClaiming(true); // Disable the button

           const provider = new ethers.providers.Web3Provider(window.ethereum as ExternalProvider);
         await provider.send('eth_requestAccounts', []); // Request account access
         const signer = provider.getSigner();
         const stakingContract = new ethers.Contract(STAKING_CONTRACT_ADDRESS, stake14Abi, signer);

         const claimTx = await stakingContract.claimReward(); // No arguments assuming claimReward() does not require them
         await claimTx.wait(); // Wait for the transaction to be mined

         alert('Rewards claimed successfully!');
       } catch (error) {
         console.error('Error claiming rewards:', error);
         alert('Failed to claim rewards. See console for more details.');
       } finally {
         setIsClaiming(false); // Re-enable the button
       }
     } else {
       alert('Ethereum wallet is not connected. Please install MetaMask or connect your wallet.');
     }
   };


     // #################################################################################################
